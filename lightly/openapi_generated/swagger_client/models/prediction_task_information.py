# coding: utf-8

"""
    Lightly API

    Lightly.ai enables you to do self-supervised learning in an easy and intuitive way. The lightly.ai OpenAPI spec defines how one can interact with our REST API to unleash the full potential of lightly.ai  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: support@lightly.ai
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Dict, Optional
try:
    # Pydantic >=v1.10.17
    from pydantic.v1 import BaseModel, Field, StrictStr
except ImportError:
    # Pydantic v1
    from pydantic import BaseModel, Field, StrictStr
from lightly.openapi_generated.swagger_client.models.categorical_distribution_per_set import CategoricalDistributionPerSet
from lightly.openapi_generated.swagger_client.models.detection_task_information import DetectionTaskInformation
from lightly.openapi_generated.swagger_client.models.numeric_distribution_per_set import NumericDistributionPerSet

class PredictionTaskInformation(BaseModel):
    """
    PredictionTaskInformation
    """
    task_type: StrictStr = Field(..., alias="taskType")
    category_id_to_name: Dict[str, StrictStr] = Field(..., alias="categoryIdToName")
    active_learning_score_distributions: Dict[str, NumericDistributionPerSet] = Field(..., alias="activeLearningScoreDistributions")
    category_distribution: CategoricalDistributionPerSet = Field(..., alias="categoryDistribution")
    category_to_counts_per_sample: Dict[str, NumericDistributionPerSet] = Field(..., alias="categoryToCountsPerSample")
    prediction_score_distribution: Optional[NumericDistributionPerSet] = Field(None, alias="predictionScoreDistribution")
    detection_task_information: Optional[DetectionTaskInformation] = Field(None, alias="detectionTaskInformation")
    category_to_image_with_category_count: Optional[CategoricalDistributionPerSet] = Field(None, alias="categoryToImageWithCategoryCount")
    __properties = ["taskType", "categoryIdToName", "activeLearningScoreDistributions", "categoryDistribution", "categoryToCountsPerSample", "predictionScoreDistribution", "detectionTaskInformation", "categoryToImageWithCategoryCount"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True
        use_enum_values = True
        extra = "forbid"

    def to_str(self, by_alias: bool = False) -> str:
        """Returns the string representation of the model"""
        return pprint.pformat(self.dict(by_alias=by_alias))

    def to_json(self, by_alias: bool = False) -> str:
        """Returns the JSON representation of the model"""
        return json.dumps(self.to_dict(by_alias=by_alias))

    @classmethod
    def from_json(cls, json_str: str) -> PredictionTaskInformation:
        """Create an instance of PredictionTaskInformation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self, by_alias: bool = False):
        """Returns the dictionary representation of the model"""
        _dict = self.dict(by_alias=by_alias,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each value in active_learning_score_distributions (dict)
        _field_dict = {}
        if self.active_learning_score_distributions:
            for _key in self.active_learning_score_distributions:
                if self.active_learning_score_distributions[_key]:
                    _field_dict[_key] = self.active_learning_score_distributions[_key].to_dict(by_alias=by_alias)
            _dict['activeLearningScoreDistributions' if by_alias else 'active_learning_score_distributions'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of category_distribution
        if self.category_distribution:
            _dict['categoryDistribution' if by_alias else 'category_distribution'] = self.category_distribution.to_dict(by_alias=by_alias)
        # override the default output from pydantic by calling `to_dict()` of each value in category_to_counts_per_sample (dict)
        _field_dict = {}
        if self.category_to_counts_per_sample:
            for _key in self.category_to_counts_per_sample:
                if self.category_to_counts_per_sample[_key]:
                    _field_dict[_key] = self.category_to_counts_per_sample[_key].to_dict(by_alias=by_alias)
            _dict['categoryToCountsPerSample' if by_alias else 'category_to_counts_per_sample'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of prediction_score_distribution
        if self.prediction_score_distribution:
            _dict['predictionScoreDistribution' if by_alias else 'prediction_score_distribution'] = self.prediction_score_distribution.to_dict(by_alias=by_alias)
        # override the default output from pydantic by calling `to_dict()` of detection_task_information
        if self.detection_task_information:
            _dict['detectionTaskInformation' if by_alias else 'detection_task_information'] = self.detection_task_information.to_dict(by_alias=by_alias)
        # override the default output from pydantic by calling `to_dict()` of category_to_image_with_category_count
        if self.category_to_image_with_category_count:
            _dict['categoryToImageWithCategoryCount' if by_alias else 'category_to_image_with_category_count'] = self.category_to_image_with_category_count.to_dict(by_alias=by_alias)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> PredictionTaskInformation:
        """Create an instance of PredictionTaskInformation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return PredictionTaskInformation.parse_obj(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in PredictionTaskInformation) in the input: " + str(obj))

        _obj = PredictionTaskInformation.parse_obj({
            "task_type": obj.get("taskType"),
            "category_id_to_name": obj.get("categoryIdToName"),
            "active_learning_score_distributions": dict(
                (_k, NumericDistributionPerSet.from_dict(_v))
                for _k, _v in obj.get("activeLearningScoreDistributions").items()
            )
            if obj.get("activeLearningScoreDistributions") is not None
            else None,
            "category_distribution": CategoricalDistributionPerSet.from_dict(obj.get("categoryDistribution")) if obj.get("categoryDistribution") is not None else None,
            "category_to_counts_per_sample": dict(
                (_k, NumericDistributionPerSet.from_dict(_v))
                for _k, _v in obj.get("categoryToCountsPerSample").items()
            )
            if obj.get("categoryToCountsPerSample") is not None
            else None,
            "prediction_score_distribution": NumericDistributionPerSet.from_dict(obj.get("predictionScoreDistribution")) if obj.get("predictionScoreDistribution") is not None else None,
            "detection_task_information": DetectionTaskInformation.from_dict(obj.get("detectionTaskInformation")) if obj.get("detectionTaskInformation") is not None else None,
            "category_to_image_with_category_count": CategoricalDistributionPerSet.from_dict(obj.get("categoryToImageWithCategoryCount")) if obj.get("categoryToImageWithCategoryCount") is not None else None
        })
        return _obj

