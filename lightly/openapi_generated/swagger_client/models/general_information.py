# coding: utf-8

"""
    Lightly API

    Lightly.ai enables you to do self-supervised learning in an easy and intuitive way. The lightly.ai OpenAPI spec defines how one can interact with our REST API to unleash the full potential of lightly.ai  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Contact: support@lightly.ai
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List
try:
    # Pydantic >=v1.10.17
    from pydantic.v1 import BaseModel, Field, conlist
except ImportError:
    # Pydantic v1
    from pydantic import BaseModel, Field, conlist
from lightly.openapi_generated.swagger_client.models.annotation_savings import AnnotationSavings
from lightly.openapi_generated.swagger_client.models.dataset_information import DatasetInformation
from lightly.openapi_generated.swagger_client.models.run_information import RunInformation
from lightly.openapi_generated.swagger_client.models.selected_and_removed_image_pair import SelectedAndRemovedImagePair
from lightly.openapi_generated.swagger_client.models.worker_information import WorkerInformation

class GeneralInformation(BaseModel):
    """
    GeneralInformation
    """
    worker_information: WorkerInformation = Field(..., alias="workerInformation")
    run_information: RunInformation = Field(..., alias="runInformation")
    dataset_information: DatasetInformation = Field(..., alias="datasetInformation")
    annotation_savings: AnnotationSavings = Field(..., alias="annotationSavings")
    selected_and_removed_image_examples: conlist(SelectedAndRemovedImagePair) = Field(..., alias="selectedAndRemovedImageExamples")
    __properties = ["workerInformation", "runInformation", "datasetInformation", "annotationSavings", "selectedAndRemovedImageExamples"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True
        use_enum_values = True
        extra = "forbid"

    def to_str(self, by_alias: bool = False) -> str:
        """Returns the string representation of the model"""
        return pprint.pformat(self.dict(by_alias=by_alias))

    def to_json(self, by_alias: bool = False) -> str:
        """Returns the JSON representation of the model"""
        return json.dumps(self.to_dict(by_alias=by_alias))

    @classmethod
    def from_json(cls, json_str: str) -> GeneralInformation:
        """Create an instance of GeneralInformation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self, by_alias: bool = False):
        """Returns the dictionary representation of the model"""
        _dict = self.dict(by_alias=by_alias,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of worker_information
        if self.worker_information:
            _dict['workerInformation' if by_alias else 'worker_information'] = self.worker_information.to_dict(by_alias=by_alias)
        # override the default output from pydantic by calling `to_dict()` of run_information
        if self.run_information:
            _dict['runInformation' if by_alias else 'run_information'] = self.run_information.to_dict(by_alias=by_alias)
        # override the default output from pydantic by calling `to_dict()` of dataset_information
        if self.dataset_information:
            _dict['datasetInformation' if by_alias else 'dataset_information'] = self.dataset_information.to_dict(by_alias=by_alias)
        # override the default output from pydantic by calling `to_dict()` of annotation_savings
        if self.annotation_savings:
            _dict['annotationSavings' if by_alias else 'annotation_savings'] = self.annotation_savings.to_dict(by_alias=by_alias)
        # override the default output from pydantic by calling `to_dict()` of each item in selected_and_removed_image_examples (list)
        _items = []
        if self.selected_and_removed_image_examples:
            for _item in self.selected_and_removed_image_examples:
                if _item:
                    _items.append(_item.to_dict(by_alias=by_alias))
            _dict['selectedAndRemovedImageExamples' if by_alias else 'selected_and_removed_image_examples'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> GeneralInformation:
        """Create an instance of GeneralInformation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return GeneralInformation.parse_obj(obj)

        # raise errors for additional fields in the input
        for _key in obj.keys():
            if _key not in cls.__properties:
                raise ValueError("Error due to additional fields (not defined in GeneralInformation) in the input: " + str(obj))

        _obj = GeneralInformation.parse_obj({
            "worker_information": WorkerInformation.from_dict(obj.get("workerInformation")) if obj.get("workerInformation") is not None else None,
            "run_information": RunInformation.from_dict(obj.get("runInformation")) if obj.get("runInformation") is not None else None,
            "dataset_information": DatasetInformation.from_dict(obj.get("datasetInformation")) if obj.get("datasetInformation") is not None else None,
            "annotation_savings": AnnotationSavings.from_dict(obj.get("annotationSavings")) if obj.get("annotationSavings") is not None else None,
            "selected_and_removed_image_examples": [SelectedAndRemovedImagePair.from_dict(_item) for _item in obj.get("selectedAndRemovedImageExamples")] if obj.get("selectedAndRemovedImageExamples") is not None else None
        })
        return _obj

