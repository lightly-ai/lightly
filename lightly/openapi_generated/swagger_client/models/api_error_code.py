# coding: utf-8

"""
    Lightly API

    Lightly.ai enables you to do self-supervised learning in an easy and intuitive way. The lightly.ai OpenAPI spec defines how one can interact with our REST API to unleash the full potential of lightly.ai  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: support@lightly.ai
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six

from lightly.openapi_generated.swagger_client.configuration import Configuration


class ApiErrorCode(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    allowed enum values
    """
    BAD_REQUEST = "BAD_REQUEST"
    NOT_IMPLEMENTED = "NOT_IMPLEMENTED"
    FORBIDDEN = "FORBIDDEN"
    UNAUTHORIZED = "UNAUTHORIZED"
    NOT_FOUND = "NOT_FOUND"
    MALFORMED_REQUEST = "MALFORMED_REQUEST"
    MALFORMED_RESPONSE = "MALFORMED_RESPONSE"
    PAYLOAD_TOO_LARGE = "PAYLOAD_TOO_LARGE"
    JWT_INVALID = "JWT_INVALID"
    JWT_MALFORMED = "JWT_MALFORMED"
    JOB_CREATION_FAILED = "JOB_CREATION_FAILED"
    JOB_UNKNOWN = "JOB_UNKNOWN"
    USER_NOT_KNOWN = "USER_NOT_KNOWN"
    USER_ACCOUNT_DEACTIVATED = "USER_ACCOUNT_DEACTIVATED"
    USER_ACCOUNT_BLOCKED = "USER_ACCOUNT_BLOCKED"
    TEAM_ACCOUNT_PLAN_INSUFFICIENT = "TEAM_ACCOUNT_PLAN_INSUFFICIENT"
    ILLEGAL_ACTION_RESOURCE_IN_USE = "ILLEGAL_ACTION_RESOURCE_IN_USE"
    DATASET_UNKNOWN = "DATASET_UNKNOWN"
    DATASET_NOT_SUPPORTED = "DATASET_NOT_SUPPORTED"
    DATASET_TAG_INVALID = "DATASET_TAG_INVALID"
    DATASET_NAME_EXISTS = "DATASET_NAME_EXISTS"
    DATASET_AT_MAX_CAPACITY = "DATASET_AT_MAX_CAPACITY"
    DATASET_DATASOURCE_UNKNOWN = "DATASET_DATASOURCE_UNKNOWN"
    DATASET_DATASOURCE_CREDENTIALS_ERROR = "DATASET_DATASOURCE_CREDENTIALS_ERROR"
    DATASET_DATASOURCE_INVALID = "DATASET_DATASOURCE_INVALID"
    DATASET_DATASOURCE_ACTION_NOT_IMPLEMENTED = "DATASET_DATASOURCE_ACTION_NOT_IMPLEMENTED"
    DATASET_DATASOURCE_ILLEGAL_ACTION = "DATASET_DATASOURCE_ILLEGAL_ACTION"
    ACCESS_CONTROL_UNKNOWN = "ACCESS_CONTROL_UNKNOWN"
    EMBEDDING_UNKNOWN = "EMBEDDING_UNKNOWN"
    EMBEDDING_NAME_EXISTS = "EMBEDDING_NAME_EXISTS"
    EMBEDDING_INVALID = "EMBEDDING_INVALID"
    EMBEDDING_NOT_READY = "EMBEDDING_NOT_READY"
    EMBEDDING_ROW_COUNT_UNKNOWN = "EMBEDDING_ROW_COUNT_UNKNOWN"
    EMBEDDING_ROW_COUNT_INVALID = "EMBEDDING_ROW_COUNT_INVALID"
    EMBEDDING_2D_UNKNOWN = "EMBEDDING_2D_UNKNOWN"
    TAG_UNKNOWN = "TAG_UNKNOWN"
    TAG_NAME_EXISTS = "TAG_NAME_EXISTS"
    TAG_INITIAL_EXISTS = "TAG_INITIAL_EXISTS"
    TAG_UNDELETABLE_NOT_A_LEAF = "TAG_UNDELETABLE_NOT_A_LEAF"
    TAG_UNDELETABLE_IS_INITIAL = "TAG_UNDELETABLE_IS_INITIAL"
    TAG_NO_TAG_IN_DATASET = "TAG_NO_TAG_IN_DATASET"
    TAG_PREVTAG_NOT_IN_DATASET = "TAG_PREVTAG_NOT_IN_DATASET"
    TAG_QUERYTAG_NOT_IN_DATASET = "TAG_QUERYTAG_NOT_IN_DATASET"
    TAG_PRESELECTEDTAG_NOT_IN_DATASET = "TAG_PRESELECTEDTAG_NOT_IN_DATASET"
    TAG_NO_SCORES_AVAILABLE = "TAG_NO_SCORES_AVAILABLE"
    SAMPLE_UNKNOWN = "SAMPLE_UNKNOWN"
    SAMPLE_THUMBNAME_UNKNOWN = "SAMPLE_THUMBNAME_UNKNOWN"
    SAMPLE_CREATE_REQUEST_INVALID_FORMAT = "SAMPLE_CREATE_REQUEST_INVALID_FORMAT"
    SAMPLE_CREATE_REQUEST_INVALID_CROP_DATA = "SAMPLE_CREATE_REQUEST_INVALID_CROP_DATA"
    PREDICTION_TASK_SCHEMA_UNKNOWN = "PREDICTION_TASK_SCHEMA_UNKNOWN"
    PREDICTION_TASK_SCHEMA_CATEGORIES_NOT_UNIQUE = "PREDICTION_TASK_SCHEMA_CATEGORIES_NOT_UNIQUE"
    SCORE_UNKNOWN = "SCORE_UNKNOWN"
    DOCKER_RUN_UNKNOWN = "DOCKER_RUN_UNKNOWN"
    DOCKER_RUN_REPORT_UNAVAILABLE = "DOCKER_RUN_REPORT_UNAVAILABLE"
    DOCKER_WORKER_UNKNOWN = "DOCKER_WORKER_UNKNOWN"
    DOCKER_WORKER_CONFIG_UNKNOWN = "DOCKER_WORKER_CONFIG_UNKNOWN"
    DOCKER_WORKER_CONFIG_IN_USE = "DOCKER_WORKER_CONFIG_IN_USE"
    DOCKER_WORKER_SCHEDULE_UNKNOWN = "DOCKER_WORKER_SCHEDULE_UNKNOWN"
    DOCKER_WORKER_SCHEDULE_UPDATE_FAILED = "DOCKER_WORKER_SCHEDULE_UPDATE_FAILED"
    METADATA_CONFIGURATION_UNKNOWN = "METADATA_CONFIGURATION_UNKNOWN"
    CUSTOM_METADATA_AT_MAX_SIZE = "CUSTOM_METADATA_AT_MAX_SIZE"

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
    }

    attribute_map = {
    }

    def __init__(self, _configuration=None):  # noqa: E501
        """ApiErrorCode - a model defined in Swagger"""  # noqa: E501
        if _configuration is None:
            _configuration = Configuration()
        self._configuration = _configuration
        self.discriminator = None

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ApiErrorCode, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ApiErrorCode):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, ApiErrorCode):
            return True

        return self.to_dict() != other.to_dict()
